<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Potyog√≥s Am≈ëba - Multi & Single</title>
    <style>
        /* --- T√âM√ÅK √âS V√ÅLTOZ√ìK --- */
        :root {
            --bg-color: #ecf0f1;
            --text-color: #2c3e50;
            --board-color: #34495e;
            --board-shadow: #2c3e50;
            --p1-color: #e74c3c; /* Piros */
            --p1-shadow: #c0392b;
            --p2-color: #f1c40f; /* S√°rga */
            --p2-shadow: #f39c12;
            --winner-glow: rgba(255, 255, 255, 0.8);
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        [data-theme="dark"] {
            --bg-color: #121212;
            --text-color: #ecf0f1;
            --board-color: #2c3e50;
            --board-shadow: #000000;
            --p1-color: #ff5252;
            --p1-shadow: #b71c1c;
            --p2-color: #ffeb3b;
            --p2-shadow: #fbc02d;
            --winner-glow: rgba(255, 255, 255, 0.5);
        }

        [data-theme="contrast"] {
            --bg-color: #ffffff;
            --text-color: #000000;
            --board-color: #444;
            --board-shadow: #222;
            --p1-color: #007bff; /* K√©k */
            --p1-shadow: #0056b3;
            --p2-color: #fd7e14; /* Narancs */
            --p2-shadow: #c65f08;
            --winner-glow: rgba(0, 255, 0, 0.8);
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            user-select: none;
            touch-action: manipulation;
            transition: background 0.3s, color 0.3s;
            -webkit-tap-highlight-color: transparent;
        }

        h1 {
            margin: 10px 0;
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }

        /* --- VEZ√âRL≈êK --- */
        .controls {
            width: 100%;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 12px;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-row {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        select, button {
            padding: 10px 12px;
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.2);
            background: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            font-weight: 500;
        }

        select { flex-grow: 1; }

        button.primary {
            background-color: var(--board-color);
            color: white;
            border: none;
            font-weight: 600;
            flex-grow: 1;
        }

        button:active { transform: scale(0.96); }

        .status {
            width: 100%;
            text-align: center;
            font-weight: bold;
            font-size: 1.1rem;
            padding: 8px;
            background: rgba(0,0,0,0.05);
            border-radius: 6px;
            box-sizing: border-box;
        }

        /* J√°t√©kos jelz≈ë a statusban */
        .status span.p1-turn { color: var(--p1-color); }
        .status span.p2-turn { color: var(--p2-color); }

        .theme-switch { display: flex; gap: 8px; }
        .theme-btn {
            width: 36px; height: 36px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.1);
            padding: 0;
            flex-grow: 0;
        }

        /* --- J√ÅT√âKT√ÅBLA --- */
        .game-board-wrapper {
            width: 100%;
            max-width: 500px;
            aspect-ratio: 7/6;
            position: relative;
        }

        .game-board {
            background-color: var(--board-color);
            width: 100%;
            height: 100%;
            padding: 2%;
            border-radius: 10px;
            box-sizing: border-box;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1.5%;
        }

        .column {
            display: flex;
            flex-direction: column;
            gap: 1.5%;
            cursor: pointer;
            position: relative;
        }

        @media (hover: hover) {
            .column:hover::after {
                content: '';
                position: absolute;
                top: -5px; left: 0; right: 0; bottom: -5px;
                background: rgba(255,255,255,0.1);
                border-radius: 50px;
                pointer-events: none;
            }
        }

        .slot {
            width: 100%;
            aspect-ratio: 1/1;
            background-color: var(--bg-color);
            border-radius: 50%;
            position: relative;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
            z-index: 1; 
        }

        .piece {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: absolute;
            top: 0; left: 0;
            z-index: 2;
            will-change: transform;
        }

        .piece.red {
            background: radial-gradient(circle at 35% 35%, #fff, var(--p1-color));
            box-shadow: 0 2px 0 var(--p1-shadow);
        }

        .piece.yellow {
            background: radial-gradient(circle at 35% 35%, #fff, var(--p2-color));
            box-shadow: 0 2px 0 var(--p2-shadow);
        }

        /* Anim√°ci√≥k */
        .shake { animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-2px, 0, 0); }
            40%, 60% { transform: translate3d(2px, 0, 0); }
        }

        .winner-slot { animation: winnerPulse 1s infinite alternate; z-index: 10; }
        @keyframes winnerPulse {
            from { box-shadow: 0 0 5px var(--winner-glow), inset 0 0 5px var(--winner-glow); transform: scale(1); }
            to { box-shadow: 0 0 15px var(--winner-glow), inset 0 0 10px var(--winner-glow); transform: scale(1.05); }
        }

        /* Helper class a rejt√©shez */
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <h1>Potyog√≥s Am≈ëba</h1>

    <div class="controls">
        <div class="control-row">
            <select id="game-mode">
                <option value="pve">1 J√°t√©kos (vs CPU)</option>
                <option value="pvp">2 J√°t√©kos (PvP)</option>
            </select>
            
            <select id="difficulty">
                <option value="1">K√∂nny≈±</option>
                <option value="2">K√∂zepes</option>
                <option value="4" selected>Halad√≥</option>
                <option value="6">Mester</option>
            </select>
        </div>

        <div class="control-row">
            <button class="primary" onclick="game.resetGame()">√öj J√°t√©k</button>
            <button id="mute-btn" onclick="soundManager.toggleMute()">üîä</button>
            <div class="theme-switch">
                <button class="theme-btn" style="background:#ecf0f1" onclick="setTheme('light')"></button>
                <button class="theme-btn" style="background:#333" onclick="setTheme('dark')"></button>
                <button class="theme-btn" style="background:#2980b9" onclick="setTheme('contrast')"></button>
            </div>
        </div>
        
        <div class="status" id="status">Ind√≠t√°s: Kattints a t√°bl√°ra!</div>
    </div>

    <div class="game-board-wrapper">
        <div id="board-container" class="game-board"></div>
    </div>

<script>
/**
 * --- AUDIO RENDSZER ---
 */
class SoundManager {
    constructor() {
        this.ctx = null;
        this.muted = false;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
    }

    toggleMute() {
        this.muted = !this.muted;
        document.getElementById('mute-btn').innerText = this.muted ? 'üîá' : 'üîä';
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (this.muted || !this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playDrop() { 
        this.init();
        this.playTone(300, 'sine', 0.2, 0.2);
        setTimeout(() => this.playTone(150, 'triangle', 0.1, 0.2), 50);
    }
    playError() { this.init(); this.playTone(150, 'sawtooth', 0.2, 0.1); }
    playWin() {
        this.init(); if (this.muted) return;
        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
            setTimeout(() => this.playTone(freq, 'sine', 0.4, 0.2), i * 150);
        });
    }
}
const soundManager = new SoundManager();

/**
 * --- J√ÅT√âK MOTOR ---
 */
const ROWS = 6;
const COLS = 7;
const PLAYER_1 = 1; // Piros
const PLAYER_2 = 2; // S√°rga (AI vagy 2. j√°t√©kos)
const EMPTY = 0;

class Connect4 {
    constructor() {
        this.board = [];
        this.currentPlayer = PLAYER_1;
        this.gameActive = true;
        this.difficulty = 4;
        this.gameMode = 'pve'; // 'pve' vagy 'pvp'
        this.isDropping = false;
        
        this.uiBoard = document.getElementById('board-container');
        this.statusDisplay = document.getElementById('status');
        
        this.initBoard();
        this.renderBoard();
        
        // Event Listeners
        document.getElementById('difficulty').addEventListener('change', (e) => {
            this.difficulty = parseInt(e.target.value);
            this.resetGame();
        });

        document.getElementById('game-mode').addEventListener('change', (e) => {
            this.gameMode = e.target.value;
            // Neh√©zs√©g v√°laszt√≥ elrejt√©se PvP m√≥dban
            const diffSelect = document.getElementById('difficulty');
            if (this.gameMode === 'pvp') {
                diffSelect.classList.add('hidden');
            } else {
                diffSelect.classList.remove('hidden');
            }
            this.resetGame();
        });
    }

    initBoard() {
        this.board = Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));
    }

    resetGame() {
        this.initBoard();
        this.currentPlayer = PLAYER_1;
        this.gameActive = true;
        this.isDropping = false;
        this.updateStatus();
        
        document.querySelectorAll('.piece').forEach(p => p.remove());
        document.querySelectorAll('.slot').forEach(s => s.classList.remove('winner-slot'));
        this.uiBoard.classList.remove('shake');
    }

    renderBoard() {
        this.uiBoard.innerHTML = '';
        for (let c = 0; c < COLS; c++) {
            const colDiv = document.createElement('div');
            colDiv.classList.add('column');
            colDiv.dataset.col = c;
            colDiv.addEventListener('click', (e) => {
                e.preventDefault();
                this.handleColumnClick(c);
            });

            for (let r = ROWS - 1; r >= 0; r--) { 
                const slot = document.createElement('div');
                slot.classList.add('slot');
                slot.dataset.row = r;
                slot.dataset.col = c;
                colDiv.appendChild(slot);
            }
            this.uiBoard.appendChild(colDiv);
        }
    }

    updateStatus(msg) {
        if (msg) {
            this.statusDisplay.innerHTML = msg;
            return;
        }
        
        // Automatikus st√°tusz gener√°l√°s
        if (!this.gameActive) return;

        if (this.gameMode === 'pve') {
            if (this.currentPlayer === PLAYER_1) {
                this.statusDisplay.innerHTML = "Te j√∂ssz! <span class='p1-turn'>(Piros)</span>";
            } else {
                this.statusDisplay.innerText = "Gondolkodom...";
            }
        } else {
            // PvP
            if (this.currentPlayer === PLAYER_1) {
                this.statusDisplay.innerHTML = "1. J√°t√©kos j√∂n <span class='p1-turn'>(Piros)</span>";
            } else {
                this.statusDisplay.innerHTML = "2. J√°t√©kos j√∂n <span class='p2-turn'>(S√°rga)</span>";
            }
        }
    }

    getNextOpenRow(board, col) {
        for (let r = 0; r < ROWS; r++) {
            if (board[r][col] === EMPTY) return r;
        }
        return -1;
    }

    handleColumnClick(col) {
        if (!this.gameActive || this.isDropping) return;
        
        // PvE m√≥dban csak akkor kattinthatsz, ha te j√∂ssz
        if (this.gameMode === 'pve' && this.currentPlayer !== PLAYER_1) return;

        soundManager.init();

        const row = this.getNextOpenRow(this.board, col);
        if (row !== -1) {
            this.makeMove(row, col, this.currentPlayer);
        } else {
            soundManager.playError();
        }
    }

    async makeMove(row, col, player) {
        this.isDropping = true;
        this.board[row][col] = player;
        
        // Friss√≠tj√ºk a st√°tuszt, hogy ne maradjon "Gondolkodom" anim√°ci√≥ k√∂zben
        if (this.gameMode === 'pve' && player === PLAYER_2) {
             this.statusDisplay.innerText = "L√©pek...";
        }

        await this.animateDrop(row, col, player);
        this.triggerImpactEffect();

        // Nyer√©s ellen≈ërz√©se
        if (this.checkWin(this.board, player)) {
            this.endGame(player);
            this.isDropping = false;
            return;
        } 
        
        // D√∂ntetlen ellen≈ërz√©se
        if (this.checkDraw(this.board)) {
            this.endGame(0);
            this.isDropping = false;
            return;
        }

        // --- K√ñR V√ÅLT√ÅS ---
        this.isDropping = false;
        
        if (this.gameMode === 'pve') {
            // PvE logika
            if (player === PLAYER_1) {
                this.currentPlayer = PLAYER_2;
                this.updateStatus();
                setTimeout(() => this.makeAIMove(), 50);
            } else {
                this.currentPlayer = PLAYER_1;
                this.updateStatus();
            }
        } else {
            // PvP logika
            this.currentPlayer = (player === PLAYER_1) ? PLAYER_2 : PLAYER_1;
            this.updateStatus();
        }
    }

    animateDrop(row, col, player) {
        return new Promise(resolve => {
            const slot = document.querySelector(`.slot[data-row='${row}'][data-col='${col}']`);
            if (slot) {
                const slotHeight = slot.getBoundingClientRect().height;
                const gap = slotHeight * 0.1;
                const dropDistance = (ROWS - 1 - row) * (slotHeight + gap) + slotHeight;

                const piece = document.createElement('div');
                piece.classList.add('piece');
                piece.classList.add(player === PLAYER_1 ? 'red' : 'yellow');
                
                piece.style.transform = `translateY(-${dropDistance}px)`;
                piece.style.transition = "transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)";
                
                slot.appendChild(piece);
                piece.offsetHeight; // Reflow
                piece.style.transform = "translateY(0)";

                setTimeout(() => resolve(), 400);
            } else resolve();
        });
    }

    triggerImpactEffect() {
        soundManager.playDrop();
        this.uiBoard.classList.remove('shake');
        void this.uiBoard.offsetWidth;
        this.uiBoard.classList.add('shake');
    }

    endGame(winner) {
        this.gameActive = false;
        soundManager.playWin();
        
        if (winner === 0) {
            this.updateStatus("D√∂ntetlen!");
        } else {
            this.highlightWin(winner);
            if (this.gameMode === 'pve') {
                if (winner === PLAYER_1) this.updateStatus("Gy≈ëzelem!");
                else this.updateStatus("Vesztett√©l.");
            } else {
                const color = winner === PLAYER_1 ? "Piros" : "S√°rga";
                this.statusDisplay.innerHTML = `Gy≈ëztes: <span class="${winner === PLAYER_1 ? 'p1-turn' : 'p2-turn'}">${color}</span>!`;
            }
        }
    }

    // --- Win Logic & AI (V√°ltozatlan, csak a v√°ltoz√≥ nevek igaz√≠tva) ---
    checkWin(board, player, returnCoords = false) {
        // Horizont√°lis
        for (let r=0;r<ROWS;r++) for (let c=0;c<COLS-3;c++)
            if (board[r][c]===player && board[r][c+1]===player && board[r][c+2]===player && board[r][c+3]===player)
                return returnCoords ? [[r,c],[r,c+1],[r,c+2],[r,c+3]] : true;
        // Vertik√°lis
        for (let r=0;r<ROWS-3;r++) for (let c=0;c<COLS;c++)
            if (board[r][c]===player && board[r+1][c]===player && board[r+2][c]===player && board[r+3][c]===player)
                return returnCoords ? [[r,c],[r+1,c],[r+2,c],[r+3,c]] : true;
        // √Åtl√≥k
        for (let r=0;r<ROWS-3;r++) for (let c=0;c<COLS-3;c++)
            if (board[r][c]===player && board[r+1][c+1]===player && board[r+2][c+2]===player && board[r+3][c+3]===player)
                return returnCoords ? [[r,c],[r+1,c+1],[r+2,c+2],[r+3,c+3]] : true;
        for (let r=3;r<ROWS;r++) for (let c=0;c<COLS-3;c++)
            if (board[r][c]===player && board[r-1][c+1]===player && board[r-2][c+2]===player && board[r-3][c+3]===player)
                return returnCoords ? [[r,c],[r-1,c+1],[r-2,c+2],[r-3,c+3]] : true;
        return false;
    }

    checkDraw(board) { return board.every(row => row.every(cell => cell !== EMPTY)); }

    highlightWin(player) {
        const coords = this.checkWin(this.board, player, true);
        if (coords) coords.forEach(([r, c]) => {
            const slot = document.querySelector(`.slot[data-row='${r}'][data-col='${c}']`);
            if (slot) slot.classList.add('winner-slot');
        });
    }

    makeAIMove() {
        let col;
        if (this.difficulty === 1) {
             if (Math.random() < 0.3) {
                 const valid = this.getValidLocations(this.board);
                 col = valid[Math.floor(Math.random() * valid.length)];
             } else col = this.minimax(this.board, 2, -Infinity, Infinity, true)[1];
        } else {
            col = this.minimax(this.board, this.difficulty, -Infinity, Infinity, true)[1];
        }
        if (col === undefined) col = this.getValidLocations(this.board)[0];
        
        const row = this.getNextOpenRow(this.board, col);
        this.makeMove(row, col, PLAYER_2);
    }

    getValidLocations(board) {
        const valid = [];
        for (let c=0; c<COLS; c++) if (board[ROWS-1][c] === EMPTY) valid.push(c);
        valid.sort((a,b) => Math.abs(a-3) - Math.abs(b-3));
        return valid;
    }

    evaluateWindow(w, p) {
        let score = 0;
        const o = p === PLAYER_2 ? PLAYER_1 : PLAYER_2;
        let pc = w.filter(c => c === p).length;
        let ec = w.filter(c => c === EMPTY).length;
        let oc = w.filter(c => c === o).length;
        if (pc === 4) score += 100;
        else if (pc === 3 && ec === 1) score += 5;
        else if (pc === 2 && ec === 2) score += 2;
        if (oc === 3 && ec === 1) score -= 4;
        return score;
    }

    scorePosition(board, piece) {
        let score = 0;
        const ca = []; for(let r=0;r<ROWS;r++) ca.push(board[r][3]);
        score += ca.filter(c => c === piece).length * 3;
        
        // Horizontal, Vertical, Diagonal checks (simplified for brevity)
        for (let r=0;r<ROWS;r++) for (let c=0;c<COLS-3;c++) 
            score += this.evaluateWindow([board[r][c], board[r][c+1], board[r][c+2], board[r][c+3]], piece);
        for (let c=0;c<COLS;c++) for (let r=0;r<ROWS-3;r++)
            score += this.evaluateWindow([board[r][c], board[r+1][c], board[r+2][c], board[r+3][c]], piece);
        for (let r=0;r<ROWS-3;r++) for (let c=0;c<COLS-3;c++)
            score += this.evaluateWindow([board[r][c], board[r+1][c+1], board[r+2][c+2], board[r+3][c+3]], piece);
        for (let r=0;r<ROWS-3;r++) for (let c=0;c<COLS-3;c++)
            score += this.evaluateWindow([board[r+3][c], board[r+2][c+1], board[r+1][c+2], board[r][c+3]], piece);
        return score;
    }

    isTerminalNode(board) {
        return this.checkWin(board, PLAYER_1) || this.checkWin(board, PLAYER_2) || this.getValidLocations(board).length === 0;
    }

    minimax(board, depth, alpha, beta, maximizingPlayer) {
        const valid = this.getValidLocations(board);
        const isTerminal = this.isTerminalNode(board);
        if (depth === 0 || isTerminal) {
            if (isTerminal) {
                if (this.checkWin(board, PLAYER_2)) return [1000000, undefined];
                else if (this.checkWin(board, PLAYER_1)) return [-1000000, undefined];
                else return [0, undefined];
            } else return [this.scorePosition(board, PLAYER_2), undefined];
        }
        if (maximizingPlayer) {
            let val = -Infinity, col = valid[Math.floor(Math.random()*valid.length)];
            for (let c of valid) {
                const r = this.getNextOpenRow(board, c);
                board[r][c] = PLAYER_2;
                const newScore = this.minimax(board, depth-1, alpha, beta, false)[0];
                board[r][c] = EMPTY;
                if (newScore > val) { val = newScore; col = c; }
                alpha = Math.max(alpha, val);
                if (alpha >= beta) break;
            }
            return [val, col];
        } else {
            let val = Infinity, col = valid[Math.floor(Math.random()*valid.length)];
            for (let c of valid) {
                const r = this.getNextOpenRow(board, c);
                board[r][c] = PLAYER_1;
                const newScore = this.minimax(board, depth-1, alpha, beta, true)[0];
                board[r][c] = EMPTY;
                if (newScore < val) { val = newScore; col = c; }
                beta = Math.min(beta, val);
                if (alpha >= beta) break;
            }
            return [val, col];
        }
    }
}

function setTheme(theme) { document.documentElement.setAttribute('data-theme', theme); }

const game = new Connect4();
</script>
</body>
</html>
